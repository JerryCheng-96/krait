#!/usr/bin/env python
# -*- coding: utf-8 -*-
import csv
import gzip
import pyfaidx
import intervaltree

from PySide.QtCore import QDir
from config import *

class Data(dict):
	def __getattr__(self, name):
		try:
			return self[name]
		except KeyError:
			raise AttributeError(name)

	def __setattr__(self, name, val):
		self[name] = val


env = Environment(loader=FileSystemLoader(TEMPLATE_DIR))
def template_render(template_name, **kwargs):
	template = env.get_template(template_name)
	return template.render(**kwargs)

def write_to_tab(tabfile, headers, cursor):
	'''
	write data to tabular file with \t separator
	@tabfile str, the save file path
	@headers tuple, the columns of the table
	@cursor, the database cursor
	'''
	with open(tabfile, 'w') as tab:
		tab.write("%s\n" % "\t".join(headers))
		for row in cursor:
			tab.write("%s\n" % "\t".join(map(str, row)))

def write_to_csv(csvfile, headers, cursor):
	with open(csvfile, 'wb') as cf:
		writer = csv.writer(cf)
		writer.writerow(headers)
		for row in cursor:
			writer.writerow(row)

def write_to_gff(gff_file, feature, cursor):
	with open(gff_file, 'w') as gff:
		gff.write("##gff-version 3\n")
		gff.write("##generated by Krait %s\n" % VERSION)
		for row in cursor:
			cols = [row.sequence, 'Krait', feature, row.start, row.end, '.', '+', '.', []]
			cols[-1].append("ID=%s%s" % (feature, row.id))
			cols[-1].append("Motif=%s" % row.motif)
			for k in row.getKeys():
				if k not in ['id', 'sequence', 'start', 'end', 'motif']:
					cols[-1].append("%s=%s" % (k.capitalize(), row.value(k)))
			cols[-1] = ";".join(cols[-1])
			gff.write("\t".join(map(str, cols))+'\n')

def write_to_gtf(gtf_file, feature, cursor):
	with open(gtf_file, 'w') as gtf:
		gtf.write("#!gtf-version 2\n")
		gtf.write("#!generated by Krait %s\n" % VERSION)
		for row in cursor:
			cols = [row.sequence, 'Krait', feature, row.start, row.end, '.', '+', '.', []]
			cols[-1].append('gene_id "%s%s"' % (feature, row.id))
			cols[-1].append('transcript_id "%s%s"' % (feature, row.id))
			cols[-1].append('motif "%s"' % row.motif)
			for k in row.getKeys():
				if k not in ['id', 'sequence', 'start', 'end', 'motif']:
					cols[-1].append('%s "%s"' % (k, row.value(k)))
			cols[-1] = "; ".join(cols[-1])
			gtf.write("\t".join(map(str, cols))+'\n')

def format_sql_where(conditions):
	symbols = ['>=', '<=', '>', '<', '=', 'in']
	conditions = conditions.split()
	for idx, cond in enumerate(conditions):
		if cond == 'in':
			items = conditions[idx+1].strip('()').split(',')
			if not items[0].isdigit():
				conditions[idx+1] = "(%s)" % ",".join(map(lambda x: "'%s'" % x, items))
			continue

		if cond in symbols:
			if not conditions[idx+1].isdigit():
				conditions[idx+1] = "'%s'" % conditions[idx+1]
			continue

		for symbol in symbols:
			if symbol in cond:
				res = cond.split(symbol)
				if not res[1].isdigit():
					res[1] = "'%s'" % res[1]
					conditions[idx] = "%s%s%s" % (res[0], symbol, res[1])

	return " ".join(conditions)

def format_fasta_sequence(sequence, length):
	seqs = []
	for idx, base in enumerate(sequence):
		seqs.append(base)
		if (idx+1) % length == 0:
			seqs.append('\n')
	seqs.append('\n')
	return "".join(seqs)

def gff_gtf_parser(annot_file):
	"""
	parse GFF, GTF, comparessed gz annotation file
	"""
	if annot_file.endswith('.gz'):
		fh = gzip.open(annot_file)
	else:
		fh = open(annot_file)

	for line in fh:
		if line[0] == '#': continue
		cols = line.strip().split('\t')
		record = Data()
		record.seqid = cols[0]
		record.feature = cols[2].upper()
		record.start = int(cols[3])
		record.end = int(cols[4])
		record.attrs = {}
		
		for item in cols[-1].split(';'):
			if not item: continue
			if 'ID=' in cols[-1]:
				name, value = item.split('=')
			else:
				name, value = item.strip().strip('"').split('"')
			record.attrs[name.strip()] = value
		
		yield record

	fh.close()

def repeatmasker_parser(rm_file):
	if rm_file.endswith('.gz'):
		fh = gzip.open(rm_file)
	else:
		fh = open(rm_file)

	for line in fh:
		if line[0] == '#': continue
		cols = line.strip().split()
		record = Data()
		record.seqid = cols[4]
		record.start = int(cols[5])
		record.end = int(cols[6])
		yield record

	fh.close()

def generate_interval_tree(annot_file, _format='gene'):
	"""
	parse gff, gtf or repeatmasker file and generate interval tree
	@para annot_file str, annotation file
	@para _format str, gene or repeatmasker
	@return interval tree
	"""
	tree = {}

	if _format == 'repeatmasker':
		for r in repeatmasker_parser(annot_file):
			if r.seqid not in tree:
				tree[r.seqid] = intervaltree.IntervalTree()
			if r.start < r.end:
				tree[r.seqid].addi(r.start, r.end, 'TE')

		return tree

	#begin parse gff or gtf annotation
	father = None
	seqid = None
	exons = []
	for r in gff_gtf_parser(annot_file):
		if r.seqid not in tree:
			tree[r.seqid] = intervaltree.IntervalTree()

		if r.feature == 'CDS':
			if r.start < r.end:
				tree[r.seqid].addi(r.start, r.end, 'CDS')
		elif r.feature == 'FIVE_PRIMER_UTR':
			if r.start < r.end:
				tree[r.seqid].addi(r.start, r.end, "5'UTR")
		elif r.feature == 'THREE_PRIMER_UTR':
			if r.start < r.end:
				tree[r.seqid].addi(r.start, r.end, "3'UTR")
		elif r.feature == 'EXON':
			if 'transcript_id' in r.attrs:
				mother = r.attrs['transcript_id']
			else:
				mother = r.attrs['Parent']

			if father == mother:
				exons.append((r.start, r.end))
			else:
				if exons:
					exons = sorted(exons, key=lambda x: x[0])
					for idx, loci in enumerate(exons):
						start, end = loci
						if start < end:
							tree[seqid].addi(start, end, 'exon')
						if idx < len(exons)-1:
							start = end+1
							end = exons[idx+1][0]-1
							if start < end:
								tree[seqid].addi(start, end, 'intron')	
				
				exons = [(r.start, r.end)]
				father = mother
				seqid = r.seqid

	exons = sorted(exons, key=lambda x: x[0])
	for idx, loci in enumerate(exons):
		start, end = loci
		if start < end:
			tree[seqid].addi(start, end, 'exon')
		if idx < len(exons)-1:
			start = end+1
			end = exons[idx+1][0]-1
			if start < end:
				tree[seqid].addi(start, end, 'intron')

	return tree

def gtf_parser(gtf_file):
	"""
	parse gtf annotation file and generate interval tree
	"""
	pass



def get_ssr_sequence(seq_file, seq_name, start, stop, flank):
	'''
	Get the SSR sequence and flanking sequences
	@para seq_file, the file path of the fasta sequence
	@para seq_name, the name of the fasta sequence
	@para start, the start position of SSR
	@para stop, the stop position of SSR
	@para flank, the length of the flanking sequence
	@return ssr sequence with flanking sequences
	'''
	fasta = pyfaidx.Fasta(seq_file, sequence_always_upper=True)
	
	#get ssr sequence
	ssr = fasta[seq_name][start-1:stop].seq
	
	#get left flanking sequence
	left_flank_start = start - flank - 1
	if left_flank_start < 0:
		left_flank_start = 0
	left_flank = fasta[seq_name][left_flank_start:start]
	
	seq_len = len(fasta[seq_name][:])
	
	#get right flanking sequence
	right_flank_stop = stop + flank
	if right_flank_stop > seq_len:
		right_flank_stop = seq_len
	right_flank = fasta[seq_name][stop:right_flank_stop]

	highlighter = SequenceHighlighter()
	meta = '%s:%s-%s %s' % (seq_name, left_flank_start+1, start, len(left_flank))
	highlighter.format_flank(left_flank, meta)
	highlighter.format_ssr(ssr)
	highlighter.format_flank(right_flank)
	return highlighter.render()
